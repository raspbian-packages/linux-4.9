commit e1ad6d09a437d26af2c1e90a2a8ae210bded8ef9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 12 17:15:56 2017 +0100

    drm: Don't race connector registration
    
    
    [ Upstream commit e6e7b48b295afa5a5ab440de0a94d9ad8b3ce2d0 ]
    
    I was under the misconception that the sysfs dev stuff can be fully
    set up, and then registered all in one step with device_add. That's
    true for properties and property groups, but not for parents and child
    devices. Those must be fully registered before you can register a
    child.
    
    Add a bit of tracking to make sure that asynchronous mst connector
    hotplugging gets this right. For consistency we rely upon the implicit
    barriers of the connector->mutex, which is taken anyway, to ensure
    that at least either the connector or device registration call will
    work out.
    
    Mildly tested since I can't reliably reproduce this on my mst box
    here.
    
    Reported-by: Dave Hansen <dave.hansen@intel.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484237756-2720-1-git-send-email-daniel.vetter@ffwll.ch
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index a103f1f..0e934a9 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -379,6 +379,9 @@ int drm_connector_register(struct drm_connector *connector)
 {
 	int ret = 0;
 
+	if (!connector->dev->registered)
+		return 0;
+
 	mutex_lock(&connector->mutex);
 	if (connector->registered)
 		goto unlock;
diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c
index 0f2fa90..362b8cd 100644
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@ -710,6 +710,8 @@ int drm_dev_register(struct drm_device *dev, unsigned long flags)
 	if (ret)
 		goto err_minors;
 
+	dev->registered = true;
+
 	if (dev->driver->load) {
 		ret = dev->driver->load(dev, flags);
 		if (ret)
@@ -749,6 +751,8 @@ void drm_dev_unregister(struct drm_device *dev)
 
 	drm_lastclose(dev);
 
+	dev->registered = false;
+
 	if (drm_core_check_feature(dev, DRIVER_MODESET))
 		drm_modeset_unregister_all(dev);
 
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index e9fb2e8..0c4f9c67 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -776,6 +776,7 @@ struct drm_device {
 	struct drm_minor *control;		/**< Control node */
 	struct drm_minor *primary;		/**< Primary node */
 	struct drm_minor *render;		/**< Render node */
+	bool registered;
 
 	/* currently active master for this device. Protected by master_mutex */
 	struct drm_master *master;
