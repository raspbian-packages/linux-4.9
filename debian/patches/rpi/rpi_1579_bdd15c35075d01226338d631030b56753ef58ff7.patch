commit bdd15c35075d01226338d631030b56753ef58ff7
Author: Coly Li <colyli@suse.de>
Date:   Tue Jan 24 15:18:46 2017 -0800

    romfs: use different way to generate fsid for BLOCK or MTD
    
    
    [ Upstream commit f598f82e204ec0b17797caaf1b0311c52d43fb9a ]
    
    Commit 8a59f5d25265 ("fs/romfs: return f_fsid for statfs(2)") generates
    a 64bit id from sb->s_bdev->bd_dev.  This is only correct when romfs is
    defined with CONFIG_ROMFS_ON_BLOCK.  If romfs is only defined with
    CONFIG_ROMFS_ON_MTD, sb->s_bdev is NULL, referencing sb->s_bdev->bd_dev
    will triger an oops.
    
    Richard Weinberger points out that when CONFIG_ROMFS_BACKED_BY_BOTH=y,
    both CONFIG_ROMFS_ON_BLOCK and CONFIG_ROMFS_ON_MTD are defined.
    Therefore when calling huge_encode_dev() to generate a 64bit id, I use
    the follow order to choose parameter,
    
    - CONFIG_ROMFS_ON_BLOCK defined
      use sb->s_bdev->bd_dev
    - CONFIG_ROMFS_ON_BLOCK undefined and CONFIG_ROMFS_ON_MTD defined
      use sb->s_dev when,
    - both CONFIG_ROMFS_ON_BLOCK and CONFIG_ROMFS_ON_MTD undefined
      leave id as 0
    
    When CONFIG_ROMFS_ON_MTD is defined and sb->s_mtd is not NULL, sb->s_dev
    is set to a device ID generated by MTD_BLOCK_MAJOR and mtd index,
    otherwise sb->s_dev is 0.
    
    This is a try-best effort to generate a uniq file system ID, if all the
    above conditions are not meet, f_fsid of this romfs instance will be 0.
    Generally only one romfs can be built on single MTD block device, this
    method is enough to identify multiple romfs instances in a computer.
    
    Link: http://lkml.kernel.org/r/1482928596-115155-1-git-send-email-colyli@suse.de
    Signed-off-by: Coly Li <colyli@suse.de>
    Reported-by: Nong Li <nongli1031@gmail.com>
    Tested-by: Nong Li <nongli1031@gmail.com>
    Cc: Richard Weinberger <richard.weinberger@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/romfs/super.c b/fs/romfs/super.c
index d0f8a38..0186fe6 100644
--- a/fs/romfs/super.c
+++ b/fs/romfs/super.c
@@ -74,6 +74,7 @@
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/uaccess.h>
+#include <linux/major.h>
 #include "internal.h"
 
 static struct kmem_cache *romfs_inode_cachep;
@@ -416,7 +417,22 @@ static void romfs_destroy_inode(struct inode *inode)
 static int romfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	u64 id = huge_encode_dev(sb->s_bdev->bd_dev);
+	u64 id = 0;
+
+	/* When calling huge_encode_dev(),
+	 * use sb->s_bdev->bd_dev when,
+	 *   - CONFIG_ROMFS_ON_BLOCK defined
+	 * use sb->s_dev when,
+	 *   - CONFIG_ROMFS_ON_BLOCK undefined and
+	 *   - CONFIG_ROMFS_ON_MTD defined
+	 * leave id as 0 when,
+	 *   - CONFIG_ROMFS_ON_BLOCK undefined and
+	 *   - CONFIG_ROMFS_ON_MTD undefined
+	 */
+	if (sb->s_bdev)
+		id = huge_encode_dev(sb->s_bdev->bd_dev);
+	else if (sb->s_dev)
+		id = huge_encode_dev(sb->s_dev);
 
 	buf->f_type = ROMFS_MAGIC;
 	buf->f_namelen = ROMFS_MAXFN;
@@ -489,6 +505,11 @@ static int romfs_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_flags |= MS_RDONLY | MS_NOATIME;
 	sb->s_op = &romfs_super_ops;
 
+#ifdef CONFIG_ROMFS_ON_MTD
+	/* Use same dev ID from the underlying mtdblock device */
+	if (sb->s_mtd)
+		sb->s_dev = MKDEV(MTD_BLOCK_MAJOR, sb->s_mtd->index);
+#endif
 	/* read the image superblock and check it */
 	rsb = kmalloc(512, GFP_KERNEL);
 	if (!rsb)
