commit f958281a0471d1930dcc2346aaaeb49964f625c4
Author: Mike Marciniszyn <mike.marciniszyn@intel.com>
Date:   Fri May 12 09:02:00 2017 -0700

    RDMA/qib,hfi1: Fix MR reference count leak on write with immediate
    
    commit 1feb40067cf04ae48d65f728d62ca255c9449178 upstream.
    
    The handling of IB_RDMA_WRITE_ONLY_WITH_IMMEDIATE will leak a memory
    reference when a buffer cannot be allocated for returning the immediate
    data.
    
    The issue is that the rkey validation has already occurred and the RNR
    nak fails to release the reference that was fruitlessly gotten.  The
    the peer will send the identical single packet request when its RNR
    timer pops.
    
    The fix is to release the held reference prior to the rnr nak exit.
    This is the only sequence the requires both rkey validation and the
    buffer allocation on the same packet.
    
    Tested-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
    Signed-off-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
    Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/infiniband/hw/hfi1/rc.c b/drivers/infiniband/hw/hfi1/rc.c
index 83198a8..4bd5b5c 100644
--- a/drivers/infiniband/hw/hfi1/rc.c
+++ b/drivers/infiniband/hw/hfi1/rc.c
@@ -2366,8 +2366,11 @@ void hfi1_rc_rcv(struct hfi1_packet *packet)
 		ret = hfi1_rvt_get_rwqe(qp, 1);
 		if (ret < 0)
 			goto nack_op_err;
-		if (!ret)
+		if (!ret) {
+			/* peer will send again */
+			rvt_put_ss(&qp->r_sge);
 			goto rnr_nak;
+		}
 		wc.ex.imm_data = ohdr->u.rc.imm_data;
 		wc.wc_flags = IB_WC_WITH_IMM;
 		goto send_last;
diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c
index 2097512..f3fe787 100644
--- a/drivers/infiniband/hw/qib/qib_rc.c
+++ b/drivers/infiniband/hw/qib/qib_rc.c
@@ -2067,8 +2067,10 @@ void qib_rc_rcv(struct qib_ctxtdata *rcd, struct ib_header *hdr,
 		ret = qib_get_rwqe(qp, 1);
 		if (ret < 0)
 			goto nack_op_err;
-		if (!ret)
+		if (!ret) {
+			rvt_put_ss(&qp->r_sge);
 			goto rnr_nak;
+		}
 		wc.ex.imm_data = ohdr->u.rc.imm_data;
 		hdrsize += 4;
 		wc.wc_flags = IB_WC_WITH_IMM;
