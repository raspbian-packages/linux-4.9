commit a2484564cd4726ff709b4e370b974d905bc8fe04
Author: Zhou Chengming <zhouchengming1@huawei.com>
Date:   Mon Jan 16 11:21:11 2017 +0800

    perf/x86/intel: Handle exclusive threadid correctly on CPU hotplug
    
    
    [ Upstream commit 4e71de7986386d5fd3765458f27d612931f27f5e ]
    
    The CPU hotplug function intel_pmu_cpu_starting() sets
    cpu_hw_events.excl_thread_id unconditionally to 1 when the shared exclusive
    counters data structure is already availabe for the sibling thread.
    
    This works during the boot process because the first sibling gets threadid
    0 assigned and the second sibling which shares the data structure gets 1.
    
    But when the first thread of the core is offlined and onlined again it
    shares the data structure with the second thread and gets exclusive thread
    id 1 assigned as well.
    
    Prevent this by checking the threadid of the already online thread.
    
    [ tglx: Rewrote changelog ]
    
    Signed-off-by: Zhou Chengming <zhouchengming1@huawei.com>
    Cc: NuoHan Qiao <qiaonuohan@huawei.com>
    Cc: ak@linux.intel.com
    Cc: peterz@infradead.org
    Cc: kan.liang@intel.com
    Cc: dave.hansen@linux.intel.com
    Cc: eranian@google.com
    Cc: qiaonuohan@huawei.com
    Cc: davidcc@google.com
    Cc: guohanjun@huawei.com
    Link: http://lkml.kernel.org/r/1484536871-3131-1-git-send-email-zhouchengming1@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c
index 3bdb917..24a6cd2 100644
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@ -3164,13 +3164,16 @@ static void intel_pmu_cpu_starting(int cpu)
 
 	if (x86_pmu.flags & PMU_FL_EXCL_CNTRS) {
 		for_each_cpu(i, topology_sibling_cpumask(cpu)) {
+			struct cpu_hw_events *sibling;
 			struct intel_excl_cntrs *c;
 
-			c = per_cpu(cpu_hw_events, i).excl_cntrs;
+			sibling = &per_cpu(cpu_hw_events, i);
+			c = sibling->excl_cntrs;
 			if (c && c->core_id == core_id) {
 				cpuc->kfree_on_online[1] = cpuc->excl_cntrs;
 				cpuc->excl_cntrs = c;
-				cpuc->excl_thread_id = 1;
+				if (!sibling->excl_thread_id)
+					cpuc->excl_thread_id = 1;
 				break;
 			}
 		}
