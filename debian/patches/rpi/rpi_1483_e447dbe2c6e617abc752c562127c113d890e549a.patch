commit e447dbe2c6e617abc752c562127c113d890e549a
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Jun 2 16:27:14 2017 +0200

    cpu/hotplug: Drop the device lock on error
    
    commit 40da1b11f01e43aad1aa6cea64681b6125e8a2a7 upstream.
    
    If a custom CPU target is specified and that one is not available _or_
    can't be interrupted then the code returns to userland without dropping a
    lock as notices by lockdep:
    
    |echo 133 > /sys/devices/system/cpu/cpu7/hotplug/target
    | ================================================
    | [ BUG: lock held when returning to user space! ]
    | ------------------------------------------------
    | bash/503 is leaving the kernel with locks still held!
    | 1 lock held by bash/503:
    |  #0:  (device_hotplug_lock){+.+...}, at: [<ffffffff815b5650>] lock_device_hotplug_sysfs+0x10/0x40
    
    So release the lock then.
    
    Fixes: 757c989b9994 ("cpu/hotplug: Make target state writeable")
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20170602142714.3ogo25f2wbq6fjpj@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/kernel/cpu.c b/kernel/cpu.c
index 99c6c56..8f52977 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -1765,13 +1765,13 @@ static ssize_t write_cpuhp_target(struct device *dev,
 	ret = !sp->name || sp->cant_stop ? -EINVAL : 0;
 	mutex_unlock(&cpuhp_state_mutex);
 	if (ret)
-		return ret;
+		goto out;
 
 	if (st->state < target)
 		ret = do_cpu_up(dev->id, target);
 	else
 		ret = do_cpu_down(dev->id, target);
-
+out:
 	unlock_device_hotplug();
 	return ret ? ret : count;
 }
