commit 0e396aed40de26d7036317e295a85b4e96eabcca
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Thu Dec 1 13:43:31 2016 -0800

    Btrfs: fix truncate down when no_holes feature is enabled
    
    
    [ Upstream commit 91298eec05cd8d4e828cf7ee5d4a6334f70cf69a ]
    
    For such a file mapping,
    
    [0-4k][hole][8k-12k]
    
    In NO_HOLES mode, we don't have the [hole] extent any more.
    Commit c1aa45759e90 ("Btrfs: fix shrinking truncate when the no_holes feature is enabled")
     fixed disk isize not being updated in NO_HOLES mode when data is not flushed.
    
    However, even if data has been flushed, we can still have trouble
    in updating disk isize since we updated disk isize to 'start' of
    the last evicted extent.
    
    Reviewed-by: Chris Mason <clm@fb.com>
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index cada3f9..a2a014b 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -4480,8 +4480,19 @@ int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
 		if (found_type > min_type) {
 			del_item = 1;
 		} else {
-			if (item_end < new_size)
+			if (item_end < new_size) {
+				/*
+				 * With NO_HOLES mode, for the following mapping
+				 *
+				 * [0-4k][hole][8k-12k]
+				 *
+				 * if truncating isize down to 6k, it ends up
+				 * isize being 8k.
+				 */
+				if (btrfs_fs_incompat(root->fs_info, NO_HOLES))
+					last_size = new_size;
 				break;
+			}
 			if (found_key.offset >= new_size)
 				del_item = 1;
 			else
