commit 7a219c12b53aad5f5bcfbaa40839394f978a05bc
Author: Vineeth Remanan Pillai <vineethp@amazon.com>
Date:   Thu Jan 19 08:35:39 2017 -0800

    xen-netfront: Fix Rx stall during network stress and OOM
    
    
    [ Upstream commit 90c311b0eeead647b708a723dbdde1eda3dcad05 ]
    
    During an OOM scenario, request slots could not be created as skb
    allocation fails. So the netback cannot pass in packets and netfront
    wrongly assumes that there is no more work to be done and it disables
    polling. This causes Rx to stall.
    
    The issue is with the retry logic which schedules the timer if the
    created slots are less than NET_RX_SLOTS_MIN. The count of new request
    slots to be pushed are calculated as a difference between new req_prod
    and rsp_cons which could be more than the actual slots, if there are
    unconsumed responses.
    
    The fix is to calculate the count of newly created slots as the
    difference between new req_prod and old req_prod.
    
    Signed-off-by: Vineeth Remanan Pillai <vineethp@amazon.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c
index 0cdcb21..599cf50 100644
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@ -321,7 +321,7 @@ static void xennet_alloc_rx_buffers(struct netfront_queue *queue)
 	queue->rx.req_prod_pvt = req_prod;
 
 	/* Not enough requests? Try again later. */
-	if (req_prod - queue->rx.rsp_cons < NET_RX_SLOTS_MIN) {
+	if (req_prod - queue->rx.sring->req_prod < NET_RX_SLOTS_MIN) {
 		mod_timer(&queue->rx_refill_timer, jiffies + (HZ/10));
 		return;
 	}
