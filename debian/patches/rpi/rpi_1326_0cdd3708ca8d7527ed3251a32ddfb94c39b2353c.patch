commit 0cdd3708ca8d7527ed3251a32ddfb94c39b2353c
Author: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Date:   Wed May 10 14:35:47 2017 -0500

    ibmvscsis: Fix the incorrect req_lim_delta
    
    commit 75dbf2d36f6b122ad3c1070fe4bf95f71bbff321 upstream.
    
    The current code is not correctly calculating the req_lim_delta.
    
    We want to make sure vscsi->credit is always incremented when
    we do not send a response for the scsi op. Thus for the case where
    there is a successfully aborted task we need to make sure the
    vscsi->credit is incremented.
    
    v2 - Moves the original location of the vscsi->credit increment
    to a better spot. Since if we increment credit, the next command
    we send back will have increased req_lim_delta. But we probably
    shouldn't be doing that until the aborted cmd is actually released.
    Otherwise the client will think that it can send a new command, and
    we could find ourselves short of command elements. Not likely, but could
    happen.
    
    This patch depends on both:
    commit 25e78531268e ("ibmvscsis: Do not send aborted task response")
    commit 98883f1b5415 ("ibmvscsis: Clear left-over abort_cmd pointers")
    
    Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
    Reviewed-by: Michael Cyr <mikecyr@linux.vnet.ibm.com>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
index ad36e51..0414843 100644
--- a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
+++ b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
@@ -1790,6 +1790,25 @@ static void ibmvscsis_send_messages(struct scsi_info *vscsi)
 					list_del(&cmd->list);
 					ibmvscsis_free_cmd_resources(vscsi,
 								     cmd);
+					/*
+					 * With a successfully aborted op
+					 * through LIO we want to increment the
+					 * the vscsi credit so that when we dont
+					 * send a rsp to the original scsi abort
+					 * op (h_send_crq), but the tm rsp to
+					 * the abort is sent, the credit is
+					 * correctly sent with the abort tm rsp.
+					 * We would need 1 for the abort tm rsp
+					 * and 1 credit for the aborted scsi op.
+					 * Thus we need to increment here.
+					 * Also we want to increment the credit
+					 * here because we want to make sure
+					 * cmd is actually released first
+					 * otherwise the client will think it
+					 * it can send a new cmd, and we could
+					 * find ourselves short of cmd elements.
+					 */
+					vscsi->credit += 1;
 				} else {
 					iue = cmd->iue;
 
@@ -2964,10 +2983,7 @@ static long srp_build_response(struct scsi_info *vscsi,
 
 	rsp->opcode = SRP_RSP;
 
-	if (vscsi->credit > 0 && vscsi->state == SRP_PROCESSING)
-		rsp->req_lim_delta = cpu_to_be32(vscsi->credit);
-	else
-		rsp->req_lim_delta = cpu_to_be32(1 + vscsi->credit);
+	rsp->req_lim_delta = cpu_to_be32(1 + vscsi->credit);
 	rsp->tag = cmd->rsp.tag;
 	rsp->flags = 0;
 
