From: Ben Hutchings <ben@decadent.org.uk>
Date: Mon, 29 Oct 2018 02:22:17 +0000
Subject: media: v4l: Avoid ABI change in 4.9.131
Forwarded: not-needed

Commit ec964c3c0045 "media: v4l: event: Prevent freeing event
subscriptions while accessed" added the member
v4l2_fh::subscribe_lock.  This structure is embedded in several larger
driver-specific structures so we can't simply move the member to
restore the old structure layout.

However, it doesn't appear that event (un)subscription will be done at
a very high rate, or that it can be done recursively.  Given that,
replace the per-file-handle mutex with a global mutex.

[carnil: Refresh for context changes in 4.9.141]
---
--- a/include/media/v4l2-fh.h
+++ b/include/media/v4l2-fh.h
@@ -42,8 +42,6 @@ struct v4l2_ctrl_handler;
  * @prio: priority of the file handler, as defined by &enum v4l2_priority
  *
  * @wait: event' s wait queue
- * @subscribe_lock: serialise changes to the subscribed list; guarantee that
- *		    the add and del event callbacks are orderly called
  * @subscribed: list of subscribed events
  * @available: list of events waiting to be dequeued
  * @navailable: number of available events at @available list
@@ -59,7 +57,6 @@ struct v4l2_fh {
 
 	/* Events */
 	wait_queue_head_t	wait;
-	struct mutex		subscribe_lock;
 	struct list_head	subscribed;
 	struct list_head	available;
 	unsigned int		navailable;
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -197,12 +197,14 @@ int v4l2_event_pending(struct v4l2_fh *f
 }
 EXPORT_SYMBOL_GPL(v4l2_event_pending);
 
+static DEFINE_MUTEX(v4l2_event_subscribe_lock);
+
 static void __v4l2_event_unsubscribe(struct v4l2_subscribed_event *sev)
 {
 	struct v4l2_fh *fh = sev->fh;
 	unsigned int i;
 
-	lockdep_assert_held(&fh->subscribe_lock);
+	lockdep_assert_held(&v4l2_event_subscribe_lock);
 	assert_spin_locked(&fh->vdev->fh_lock);
 
 	/* Remove any pending events for this subscription */
@@ -240,7 +242,7 @@ int v4l2_event_subscribe(struct v4l2_fh
 	sev->ops = ops;
 	sev->elems = elems;
 
-	mutex_lock(&fh->subscribe_lock);
+	mutex_lock(&v4l2_event_subscribe_lock);
 
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
@@ -261,7 +263,7 @@ int v4l2_event_subscribe(struct v4l2_fh
 		}
 	}
 
-	mutex_unlock(&fh->subscribe_lock);
+	mutex_unlock(&v4l2_event_subscribe_lock);
 
 	return ret;
 }
@@ -301,7 +303,7 @@ int v4l2_event_unsubscribe(struct v4l2_f
 		return 0;
 	}
 
-	mutex_lock(&fh->subscribe_lock);
+	mutex_lock(&v4l2_event_subscribe_lock);
 
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
@@ -314,7 +316,7 @@ int v4l2_event_unsubscribe(struct v4l2_f
 	if (sev && sev->ops && sev->ops->del)
 		sev->ops->del(sev);
 
-	mutex_unlock(&fh->subscribe_lock);
+	mutex_unlock(&v4l2_event_subscribe_lock);
 
 	kfree(sev);
 
--- a/drivers/media/v4l2-core/v4l2-fh.c
+++ b/drivers/media/v4l2-core/v4l2-fh.c
@@ -50,7 +50,6 @@ void v4l2_fh_init(struct v4l2_fh *fh, st
 	INIT_LIST_HEAD(&fh->available);
 	INIT_LIST_HEAD(&fh->subscribed);
 	fh->sequence = -1;
-	mutex_init(&fh->subscribe_lock);
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_init);
 
@@ -96,7 +95,6 @@ void v4l2_fh_exit(struct v4l2_fh *fh)
 		return;
 	v4l_disable_media_source(fh->vdev);
 	v4l2_event_unsubscribe_all(fh);
-	mutex_destroy(&fh->subscribe_lock);
 	fh->vdev = NULL;
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_exit);
