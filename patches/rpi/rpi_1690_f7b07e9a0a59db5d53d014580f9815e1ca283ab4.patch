commit f7b07e9a0a59db5d53d014580f9815e1ca283ab4
Author: Raju Rangoju <rajur@chelsio.com>
Date:   Mon Jun 19 19:46:00 2017 +0530

    cxgb4: notify uP to route ctrlq compl to rdma rspq
    
    commit dec6b33163d24e2c19ba521c89fffbaab53ae986 upstream.
    
    During the module initialisation there is a possible race
    (basically race between uld and lld) where neither the uld
    nor lld notifies the uP about where to route the ctrl queue
    completions. LLD skips notifying uP as the rdma queues were
    not created by then (will leave it to ULD to notify the uP).
    As the ULD comes up, it also skips notifying the uP as the
    flag FULL_INIT_DONE is not set yet (ULD assumes that the
    interface is not up yet).
    
    Consequently, this race between uld and lld leaves uP
    unnotified about where to send the ctrl queue completions
    to, leading to iwarp RI_RES WR failure.
    
    Here is the race:
    
    CPU 0                                   CPU1
    
    - allocates nic rx queus
    - t4_sge_alloc_ctrl_txq()
    (if rdma rsp queues exists,
    tell uP to route ctrl queue
    compl to rdma rspq)
                                    - acquires the mutex_lock
                                    - allocates rdma response queues
                                    - if FULL_INIT_DONE set,
                                      tell uP to route ctrl queue compl
                                      to rdma rspq
                                    - relinquishes mutex_lock
    - acquires the mutex_lock
    - enable_rx()
    - set FULL_INIT_DONE
    - relinquishes mutex_lock
    
    This patch fixes the above issue.
    
    Fixes: e7519f9926f1('cxgb4: avoid enabling napi twice to the same queue')
    Signed-off-by: Raju Rangoju <rajur@chelsio.com>
    Acked-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index f9c2feb..0c2a32a 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -2201,9 +2201,10 @@ static int cxgb_up(struct adapter *adap)
 {
 	int err;
 
+	mutex_lock(&uld_mutex);
 	err = setup_sge_queues(adap);
 	if (err)
-		goto out;
+		goto rel_lock;
 	err = setup_rss(adap);
 	if (err)
 		goto freeq;
@@ -2227,7 +2228,6 @@ static int cxgb_up(struct adapter *adap)
 			goto irq_err;
 	}
 
-	mutex_lock(&uld_mutex);
 	enable_rx(adap);
 	t4_sge_start(adap);
 	t4_intr_enable(adap);
@@ -2240,13 +2240,15 @@ static int cxgb_up(struct adapter *adap)
 #endif
 	/* Initialize hash mac addr list*/
 	INIT_LIST_HEAD(&adap->mac_hlist);
- out:
 	return err;
+
  irq_err:
 	dev_err(adap->pdev_dev, "request_irq failed, err %d\n", err);
  freeq:
 	t4_free_sge_resources(adap);
-	goto out;
+ rel_lock:
+	mutex_unlock(&uld_mutex);
+	return err;
 }
 
 static void cxgb_down(struct adapter *adapter)
